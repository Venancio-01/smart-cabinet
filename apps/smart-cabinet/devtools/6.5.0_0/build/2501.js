'use strict'; (self.webpackChunk_vue_devtools_shell_chrome = self.webpackChunk_vue_devtools_shell_chrome || []).push([[2501], {
  32501: (e, t, n) => {
    n.r(t), n.d(t, { getJavaScriptWorker: () => E, getTypeScriptWorker: () => K, setupJavaScript: () => N, setupTypeScript: () => O }); let r; const i = n(67181); const o = function (e, t, n, r) {
      function i(e) { return e instanceof n ? e : new n((t) => { t(e) }) } return new (n || (n = Promise))((n, o) => {
        function s(e) {
          try { u(r.next(e)) }
          catch (t) { o(t) }
        } function a(e) {
          try { u(r.throw(e)) }
          catch (t) { o(t) }
        } function u(e) { e.done ? n(e.value) : i(e.value).then(s, a) }u((r = r.apply(e, t || [])).next())
      })
    }; const s = function (e, t) {
      let n; let r; let i; let o; let s = {
        label: 0,
        sent() {
          if (1 & i[0])
            throw i[1]; return i[1]
        },
        trys: [],
        ops: [],
      }; return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol === 'function' && (o[Symbol.iterator] = function () { return this }), o; function a(e) { return function (t) { return u([e, t]) } } function u(o) {
        if (n)
          throw new TypeError('Generator is already executing.'); while (s) {
          try {
            if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done)
              return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0:case 1:i = o; break; case 4:return s.label++, { value: o[1], done: !1 }; case 5:s.label++, r = o[1], o = [0]; continue; case 7:o = s.ops.pop(), s.trys.pop(); continue; default:if (i = s.trys, !(i = i.length > 0 && i[i.length - 1]) && (o[0] === 6 || o[0] === 2)) { s = 0; continue } if (o[0] === 3 && (!i || o[1] > i[0] && o[1] < i[3])) { s.label = o[1]; break } if (o[0] === 6 && s.label < i[1]) { s.label = i[1], i = o; break } if (i && s.label < i[2]) { s.label = i[2], s.ops.push(o); break }i[2] && s.ops.pop(), s.trys.pop(); continue }o = t.call(e, s)
          }
          catch (a) { o = [6, a], r = 0 }
          finally { n = i = 0 }
        } if (5 & o[0])
          throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 }
      }
    }; const a = (function () {
      function e(e, t) { const n = this; this._modeId = e, this._defaults = t, this._worker = null, this._client = null, this._configChangeListener = this._defaults.onDidChange(() => { return n._stopWorker() }), this._updateExtraLibsToken = 0, this._extraLibsChangeListener = this._defaults.onDidExtraLibsChange(() => { return n._updateExtraLibs() }) } return e.prototype._stopWorker = function () { this._worker && (this._worker.dispose(), this._worker = null), this._client = null }, e.prototype.dispose = function () { this._configChangeListener.dispose(), this._extraLibsChangeListener.dispose(), this._stopWorker() }, e.prototype._updateExtraLibs = function () { return o(this, void 0, void 0, function () { let e, t; return s(this, function (n) { switch (n.label) { case 0:return this._worker ? (e = ++this._updateExtraLibsToken, [4, this._worker.getProxy()]) : [2]; case 1:return t = n.sent(), this._updateExtraLibsToken !== e ? [2] : (t.updateExtraLibs(this._defaults.getExtraLibs()), [2]) } }) }) }, e.prototype._getClient = function () { const e = this; if (!this._client) { this._worker = i.j6.createWebWorker({ moduleId: 'vs/language/typescript/tsWorker', label: this._modeId, keepIdleModels: !0, createData: { compilerOptions: this._defaults.getCompilerOptions(), extraLibs: this._defaults.getExtraLibs(), customWorkerPath: this._defaults.workerOptions.customWorkerPath } }); let t = this._worker.getProxy(); this._defaults.getEagerModelSync() && (t = t.then((t) => { return e._worker ? e._worker.withSyncedResources(i.j6.getModels().filter((t) => { return t.getModeId() === e._modeId }).map((e) => { return e.uri })) : t })), this._client = t } return this._client }, e.prototype.getLanguageServiceWorker = function () {
        for (var e, t = this, n = [], r = 0; r < arguments.length; r++)n[r] = arguments[r]; return this._getClient().then((t) => { e = t }).then((e) => {
          if (t._worker)
            return t._worker.withSyncedResources(n)
        }).then((t) => { return e })
      }, e
    }()); const u = { 'lib.d.ts': !0, 'lib.dom.d.ts': !0, 'lib.dom.iterable.d.ts': !0, 'lib.es2015.collection.d.ts': !0, 'lib.es2015.core.d.ts': !0, 'lib.es2015.d.ts': !0, 'lib.es2015.generator.d.ts': !0, 'lib.es2015.iterable.d.ts': !0, 'lib.es2015.promise.d.ts': !0, 'lib.es2015.proxy.d.ts': !0, 'lib.es2015.reflect.d.ts': !0, 'lib.es2015.symbol.d.ts': !0, 'lib.es2015.symbol.wellknown.d.ts': !0, 'lib.es2016.array.include.d.ts': !0, 'lib.es2016.d.ts': !0, 'lib.es2016.full.d.ts': !0, 'lib.es2017.d.ts': !0, 'lib.es2017.full.d.ts': !0, 'lib.es2017.intl.d.ts': !0, 'lib.es2017.object.d.ts': !0, 'lib.es2017.sharedmemory.d.ts': !0, 'lib.es2017.string.d.ts': !0, 'lib.es2017.typedarrays.d.ts': !0, 'lib.es2018.asyncgenerator.d.ts': !0, 'lib.es2018.asynciterable.d.ts': !0, 'lib.es2018.d.ts': !0, 'lib.es2018.full.d.ts': !0, 'lib.es2018.intl.d.ts': !0, 'lib.es2018.promise.d.ts': !0, 'lib.es2018.regexp.d.ts': !0, 'lib.es2019.array.d.ts': !0, 'lib.es2019.d.ts': !0, 'lib.es2019.full.d.ts': !0, 'lib.es2019.object.d.ts': !0, 'lib.es2019.string.d.ts': !0, 'lib.es2019.symbol.d.ts': !0, 'lib.es2020.bigint.d.ts': !0, 'lib.es2020.d.ts': !0, 'lib.es2020.full.d.ts': !0, 'lib.es2020.intl.d.ts': !0, 'lib.es2020.promise.d.ts': !0, 'lib.es2020.sharedmemory.d.ts': !0, 'lib.es2020.string.d.ts': !0, 'lib.es2020.symbol.wellknown.d.ts': !0, 'lib.es5.d.ts': !0, 'lib.es6.d.ts': !0, 'lib.esnext.d.ts': !0, 'lib.esnext.full.d.ts': !0, 'lib.esnext.intl.d.ts': !0, 'lib.esnext.promise.d.ts': !0, 'lib.esnext.string.d.ts': !0, 'lib.esnext.weakref.d.ts': !0, 'lib.scripthost.d.ts': !0, 'lib.webworker.d.ts': !0, 'lib.webworker.importscripts.d.ts': !0, 'lib.webworker.iterable.d.ts': !0 }; const l = (function () {
      let e = function (t, n) { return e = Object.setPrototypeOf || Array.isArray({ __proto__: [] }) && function (e, t) { e.__proto__ = t } || function (e, t) { for (const n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) }, e(t, n) }; return function (t, n) {
        if (typeof n !== 'function' && n !== null)
          throw new TypeError(`Class extends value ${String(n)} is not a constructor or null`); function r() { this.constructor = t }e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r())
      }
    }()); const c = function (e, t, n, r) {
      function i(e) { return e instanceof n ? e : new n((t) => { t(e) }) } return new (n || (n = Promise))((n, o) => {
        function s(e) {
          try { u(r.next(e)) }
          catch (t) { o(t) }
        } function a(e) {
          try { u(r.throw(e)) }
          catch (t) { o(t) }
        } function u(e) { e.done ? n(e.value) : i(e.value).then(s, a) }u((r = r.apply(e, t || [])).next())
      })
    }; const d = function (e, t) {
      let n; let r; let i; let o; let s = {
        label: 0,
        sent() {
          if (1 & i[0])
            throw i[1]; return i[1]
        },
        trys: [],
        ops: [],
      }; return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol === 'function' && (o[Symbol.iterator] = function () { return this }), o; function a(e) { return function (t) { return u([e, t]) } } function u(o) {
        if (n)
          throw new TypeError('Generator is already executing.'); while (s) {
          try {
            if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done)
              return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0:case 1:i = o; break; case 4:return s.label++, { value: o[1], done: !1 }; case 5:s.label++, r = o[1], o = [0]; continue; case 7:o = s.ops.pop(), s.trys.pop(); continue; default:if (i = s.trys, !(i = i.length > 0 && i[i.length - 1]) && (o[0] === 6 || o[0] === 2)) { s = 0; continue } if (o[0] === 3 && (!i || o[1] > i[0] && o[1] < i[3])) { s.label = o[1]; break } if (o[0] === 6 && s.label < i[1]) { s.label = i[1], i = o; break } if (i && s.label < i[2]) { s.label = i[2], s.ops.push(o); break }i[2] && s.ops.pop(), s.trys.pop(); continue }o = t.call(e, s)
          }
          catch (a) { o = [6, a], r = 0 }
          finally { n = i = 0 }
        } if (5 & o[0])
          throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 }
      }
    }; function p(e, t, n) {
      if (void 0 === n && (n = 0), typeof e === 'string')
        return e; if (void 0 === e)
        return ''; let r = ''; if (n) { r += t; for (let i = 0; i < n; i++)r += '  ' } if (r += e.messageText, n++, e.next)
        for (let o = 0, s = e.next; o < s.length; o++) { const a = s[o]; r += p(a, t, n) } return r
    } function f(e) { return e ? e.map((e) => { return e.text }).join('') : '' }(function (e) { e[e.None = 0] = 'None', e[e.Block = 1] = 'Block', e[e.Smart = 2] = 'Smart' })(r || (r = {})); let h; const g = (function () { function e(e) { this._worker = e } return e.prototype._textSpanToRange = function (e, t) { const n = e.getPositionAt(t.start); const r = e.getPositionAt(t.start + t.length); const i = n.lineNumber; const o = n.column; const s = r.lineNumber; const a = r.column; return { startLineNumber: i, startColumn: o, endLineNumber: s, endColumn: a } }, e }()); const m = (function () {
      function e(e) { this._worker = e, this._libFiles = {}, this._hasFetchedLibFiles = !1, this._fetchLibFilesPromise = null } return e.prototype.isLibFile = function (e) { return !!e && (e.path.indexOf('/lib.') === 0 && !!u[e.path.slice(1)]) }, e.prototype.getOrCreateModel = function (e) { const t = i.j6.getModel(e); return t || (this.isLibFile(e) && this._hasFetchedLibFiles ? i.j6.createModel(this._libFiles[e.path.slice(1)], 'typescript', e) : null) }, e.prototype._containsLibFile = function (e) {
        for (let t = 0, n = e; t < n.length; t++) {
          const r = n[t]; if (this.isLibFile(r))
            return !0
        } return !1
      }, e.prototype.fetchLibFilesIfNecessary = function (e) { return c(this, void 0, void 0, function () { return d(this, function (t) { switch (t.label) { case 0:return this._containsLibFile(e) ? [4, this._fetchLibFiles()] : [2]; case 1:return t.sent(), [2] } }) }) }, e.prototype._fetchLibFiles = function () { const e = this; return this._fetchLibFilesPromise || (this._fetchLibFilesPromise = this._worker().then((e) => { return e.getLibFiles() }).then((t) => { e._hasFetchedLibFiles = !0, e._libFiles = t })), this._fetchLibFilesPromise }, e
    }()); (function (e) { e[e.Warning = 0] = 'Warning', e[e.Error = 1] = 'Error', e[e.Suggestion = 2] = 'Suggestion', e[e.Message = 3] = 'Message' })(h || (h = {})); const b = (function (e) { function t(t, n, r, o) { const s = e.call(this, o) || this; s._libFiles = t, s._defaults = n, s._selector = r, s._disposables = [], s._listener = Object.create(null); const a = function (e) { if (e.getModeId() === r) { let t; const n = function () { const t = s._defaults.getDiagnosticsOptions().onlyVisible; t ? e.isAttachedToEditor() && s._doValidate(e) : s._doValidate(e) }; const o = e.onDidChangeContent(() => { clearTimeout(t), t = setTimeout(n, 500) }); const a = e.onDidChangeAttached(() => { const t = s._defaults.getDiagnosticsOptions().onlyVisible; t && (e.isAttachedToEditor() ? n() : i.j6.setModelMarkers(e, s._selector, [])) }); s._listener[e.uri.toString()] = { dispose() { o.dispose(), a.dispose(), clearTimeout(t) } }, n() } }; const u = function (e) { i.j6.setModelMarkers(e, s._selector, []); const t = e.uri.toString(); s._listener[t] && (s._listener[t].dispose(), delete s._listener[t]) }; s._disposables.push(i.j6.onDidCreateModel((e) => { return a(e) })), s._disposables.push(i.j6.onWillDisposeModel(u)), s._disposables.push(i.j6.onDidChangeModelLanguage((e) => { u(e.model), a(e.model) })), s._disposables.push({ dispose() { for (let e = 0, t = i.j6.getModels(); e < t.length; e++) { const n = t[e]; u(n) } } }); const l = function () { for (let e = 0, t = i.j6.getModels(); e < t.length; e++) { const n = t[e]; u(n), a(n) } }; return s._disposables.push(s._defaults.onDidChange(l)), s._disposables.push(s._defaults.onDidExtraLibsChange(l)), i.j6.getModels().forEach((e) => { return a(e) }), s } return l(t, e), t.prototype.dispose = function () { this._disposables.forEach((e) => { return e && e.dispose() }), this._disposables = [] }, t.prototype._doValidate = function (e) { return c(this, void 0, void 0, function () { let t; let n; let r; let o; let s; let a; let u; let l; let c; const p = this; return d(this, function (d) { switch (d.label) { case 0:return [4, this._worker(e.uri)]; case 1:return t = d.sent(), e.isDisposed() ? [2] : (n = [], r = this._defaults.getDiagnosticsOptions(), o = r.noSyntaxValidation, s = r.noSemanticValidation, a = r.noSuggestionDiagnostics, o || n.push(t.getSyntacticDiagnostics(e.uri.toString())), s || n.push(t.getSemanticDiagnostics(e.uri.toString())), a || n.push(t.getSuggestionDiagnostics(e.uri.toString())), [4, Promise.all(n)]); case 2:return u = d.sent(), !u || e.isDisposed() ? [2] : (l = u.reduce((e, t) => { return t.concat(e) }, []).filter((e) => { return !(p._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).includes(e.code) }), c = l.map((e) => { return e.relatedInformation || [] }).reduce((e, t) => { return t.concat(e) }, []).map((e) => { return e.file ? i.Sf.parse(e.file.fileName) : null }), [4, this._libFiles.fetchLibFilesIfNecessary(c)]); case 3:return d.sent(), e.isDisposed() ? [2] : (i.j6.setModelMarkers(e, this._selector, l.map((t) => { return p._convertDiagnostics(e, t) })), [2]) } }) }) }, t.prototype._convertDiagnostics = function (e, t) { const n = t.start || 0; const r = t.length || 1; const o = e.getPositionAt(n); const s = o.lineNumber; const a = o.column; const u = e.getPositionAt(n + r); const l = u.lineNumber; const c = u.column; const d = []; return t.reportsUnnecessary && d.push(i.eB.Unnecessary), t.reportsDeprecated && d.push(i.eB.Deprecated), { severity: this._tsDiagnosticCategoryToMarkerSeverity(t.category), startLineNumber: s, startColumn: a, endLineNumber: l, endColumn: c, message: p(t.messageText, '\n'), code: t.code.toString(), tags: d, relatedInformation: this._convertRelatedInformation(e, t.relatedInformation) } }, t.prototype._convertRelatedInformation = function (e, t) { const n = this; if (t) { const r = []; return t.forEach((t) => { let o = e; if (t.file) { const s = i.Sf.parse(t.file.fileName); o = n._libFiles.getOrCreateModel(s) } if (o) { const a = t.start || 0; const u = t.length || 1; const l = o.getPositionAt(a); const c = l.lineNumber; const d = l.column; const f = o.getPositionAt(a + u); const h = f.lineNumber; const g = f.column; r.push({ resource: o.uri, startLineNumber: c, startColumn: d, endLineNumber: h, endColumn: g, message: p(t.messageText, '\n') }) } }), r } }, t.prototype._tsDiagnosticCategoryToMarkerSeverity = function (e) { switch (e) { case h.Error:return i.ZL.Error; case h.Message:return i.ZL.Info; case h.Warning:return i.ZL.Warning; case h.Suggestion:return i.ZL.Hint } return i.ZL.Info }, t }(g)); const v = (function (e) {
      function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), Object.defineProperty(t.prototype, 'triggerCharacters', { get() { return ['.'] }, enumerable: !1, configurable: !0 }), t.prototype.provideCompletionItems = function (e, n, r, o) { return c(this, void 0, void 0, function () { let r, o, s, a, u, l, c; return d(this, function (d) { switch (d.label) { case 0:return r = e.getWordUntilPosition(n), o = new i.e6(n.lineNumber, r.startColumn, n.lineNumber, r.endColumn), s = e.uri, a = e.getOffsetAt(n), [4, this._worker(s)]; case 1:return u = d.sent(), e.isDisposed() ? [2] : [4, u.getCompletionsAtPosition(s.toString(), a)]; case 2:return l = d.sent(), !l || e.isDisposed() ? [2] : (c = l.entries.map((r) => { let u; let l = o; if (r.replacementSpan) { const c = e.getPositionAt(r.replacementSpan.start); const d = e.getPositionAt(r.replacementSpan.start + r.replacementSpan.length); l = new i.e6(c.lineNumber, c.column, d.lineNumber, d.column) } const p = []; return ((u = r.kindModifiers) === null || void 0 === u ? void 0 : u.indexOf('deprecated')) !== -1 && p.push(i.Mj.CompletionItemTag.Deprecated), { uri: s, position: n, offset: a, range: l, label: r.name, insertText: r.name, sortText: r.sortText, kind: t.convertKind(r.kind), tags: p } }), [2, { suggestions: c }]) } }) }) }, t.prototype.resolveCompletionItem = function (e, n) { return c(this, void 0, void 0, function () { let n, r, i, o, s, a; return d(this, function (u) { switch (u.label) { case 0:return n = e, r = n.uri, i = n.position, o = n.offset, [4, this._worker(r)]; case 1:return s = u.sent(), [4, s.getCompletionEntryDetails(r.toString(), o, n.label)]; case 2:return a = u.sent(), a ? [2, { uri: r, position: i, label: a.name, kind: t.convertKind(a.kind), detail: f(a.displayParts), documentation: { value: t.createDocumentationString(a) } }] : [2, n] } }) }) }, t.convertKind = function (e) { switch (e) { case M.primitiveType:case M.keyword:return i.Mj.CompletionItemKind.Keyword; case M.variable:case M.localVariable:return i.Mj.CompletionItemKind.Variable; case M.memberVariable:case M.memberGetAccessor:case M.memberSetAccessor:return i.Mj.CompletionItemKind.Field; case M.function:case M.memberFunction:case M.constructSignature:case M.callSignature:case M.indexSignature:return i.Mj.CompletionItemKind.Function; case M.enum:return i.Mj.CompletionItemKind.Enum; case M.module:return i.Mj.CompletionItemKind.Module; case M.class:return i.Mj.CompletionItemKind.Class; case M.interface:return i.Mj.CompletionItemKind.Interface; case M.warning:return i.Mj.CompletionItemKind.File } return i.Mj.CompletionItemKind.Property }, t.createDocumentationString = function (e) {
        let t = f(e.documentation); if (e.tags)
          for (let n = 0, r = e.tags; n < r.length; n++) { const i = r[n]; t += `\n\n${y(i)}` } return t
      }, t
    }(g)); function y(e) {
      let t = `*@${e.name}*`; if (e.name === 'param' && e.text) { const n = e.text.split(' '); const r = n[0]; const i = n.slice(1); t += `\`${r}\``, i.length > 0 && (t += ` — ${i.join(' ')}`) }
      else { e.text && (t += ` — ${e.text}`) } return t
    } const _ = (function (e) { function t() { const t = e !== null && e.apply(this, arguments) || this; return t.signatureHelpTriggerCharacters = ['(', ','], t } return l(t, e), t._toSignatureHelpTriggerReason = function (e) { switch (e.triggerKind) { case i.Mj.SignatureHelpTriggerKind.TriggerCharacter:return e.triggerCharacter ? e.isRetrigger ? { kind: 'retrigger', triggerCharacter: e.triggerCharacter } : { kind: 'characterTyped', triggerCharacter: e.triggerCharacter } : { kind: 'invoked' }; case i.Mj.SignatureHelpTriggerKind.ContentChange:return e.isRetrigger ? { kind: 'retrigger' } : { kind: 'invoked' }; case i.Mj.SignatureHelpTriggerKind.Invoke:default:return { kind: 'invoked' } } }, t.prototype.provideSignatureHelp = function (e, n, r, i) { return c(this, void 0, void 0, function () { let r, o, s, a, u; return d(this, function (l) { switch (l.label) { case 0:return r = e.uri, o = e.getOffsetAt(n), [4, this._worker(r)]; case 1:return s = l.sent(), e.isDisposed() ? [2] : [4, s.getSignatureHelpItems(r.toString(), o, { triggerReason: t._toSignatureHelpTriggerReason(i) })]; case 2:return a = l.sent(), !a || e.isDisposed() ? [2] : (u = { activeSignature: a.selectedItemIndex, activeParameter: a.argumentIndex, signatures: [] }, a.items.forEach((e) => { const t = { label: '', parameters: [] }; t.documentation = { value: f(e.documentation) }, t.label += f(e.prefixDisplayParts), e.parameters.forEach((n, r, i) => { const o = f(n.displayParts); const s = { label: o, documentation: { value: f(n.documentation) } }; t.label += o, t.parameters.push(s), r < i.length - 1 && (t.label += f(e.separatorDisplayParts)) }), t.label += f(e.suffixDisplayParts), u.signatures.push(t) }), [2, { value: u, dispose() {} }]) } }) }) }, t }(g)); const S = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t.prototype.provideHover = function (e, t, n) { return c(this, void 0, void 0, function () { let n, r, i, o, s, a, u; return d(this, function (l) { switch (l.label) { case 0:return n = e.uri, r = e.getOffsetAt(t), [4, this._worker(n)]; case 1:return i = l.sent(), e.isDisposed() ? [2] : [4, i.getQuickInfoAtPosition(n.toString(), r)]; case 2:return o = l.sent(), !o || e.isDisposed() ? [2] : (s = f(o.documentation), a = o.tags ? o.tags.map((e) => { return y(e) }).join('  \n\n') : '', u = f(o.displayParts), [2, { range: this._textSpanToRange(e, o.textSpan), contents: [{ value: `\`\`\`typescript\n${u}\n\`\`\`\n` }, { value: s + (a ? `\n\n${a}` : '') }] }]) } }) }) }, t }(g)); const w = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t.prototype.provideDocumentHighlights = function (e, t, n) { return c(this, void 0, void 0, function () { let n; let r; let o; let s; const a = this; return d(this, function (u) { switch (u.label) { case 0:return n = e.uri, r = e.getOffsetAt(t), [4, this._worker(n)]; case 1:return o = u.sent(), e.isDisposed() ? [2] : [4, o.getOccurrencesAtPosition(n.toString(), r)]; case 2:return s = u.sent(), !s || e.isDisposed() ? [2] : [2, s.map((t) => { return { range: a._textSpanToRange(e, t.textSpan), kind: t.isWriteAccess ? i.Mj.DocumentHighlightKind.Write : i.Mj.DocumentHighlightKind.Text } })] } }) }) }, t }(g)); const k = (function (e) {
      function t(t, n) { const r = e.call(this, n) || this; return r._libFiles = t, r } return l(t, e), t.prototype.provideDefinition = function (e, t, n) {
        return c(this, void 0, void 0, function () {
          let n, r, o, s, a, u, l, c, p, f; return d(this, function (d) {
            switch (d.label) {
              case 0:return n = e.uri, r = e.getOffsetAt(t), [4, this._worker(n)]; case 1:return o = d.sent(), e.isDisposed() ? [2] : [4, o.getDefinitionAtPosition(n.toString(), r)]; case 2:return s = d.sent(), !s || e.isDisposed() ? [2] : [4, this._libFiles.fetchLibFilesIfNecessary(s.map((e) => { return i.Sf.parse(e.fileName) }))]; case 3:if (d.sent(), e.isDisposed())
                return [2]; for (a = [], u = 0, l = s; u < l.length; u++)c = l[u], p = i.Sf.parse(c.fileName), f = this._libFiles.getOrCreateModel(p), f && a.push({ uri: p, range: this._textSpanToRange(f, c.textSpan) }); return [2, a]
            }
          })
        })
      }, t
    }(g)); const x = (function (e) {
      function t(t, n) { const r = e.call(this, n) || this; return r._libFiles = t, r } return l(t, e), t.prototype.provideReferences = function (e, t, n, r) {
        return c(this, void 0, void 0, function () {
          let n, r, o, s, a, u, l, c, p, f; return d(this, function (d) {
            switch (d.label) {
              case 0:return n = e.uri, r = e.getOffsetAt(t), [4, this._worker(n)]; case 1:return o = d.sent(), e.isDisposed() ? [2] : [4, o.getReferencesAtPosition(n.toString(), r)]; case 2:return s = d.sent(), !s || e.isDisposed() ? [2] : [4, this._libFiles.fetchLibFilesIfNecessary(s.map((e) => { return i.Sf.parse(e.fileName) }))]; case 3:if (d.sent(), e.isDisposed())
                return [2]; for (a = [], u = 0, l = s; u < l.length; u++)c = l[u], p = i.Sf.parse(c.fileName), f = this._libFiles.getOrCreateModel(p), f && a.push({ uri: p, range: this._textSpanToRange(f, c.textSpan) }); return [2, a]
            }
          })
        })
      }, t
    }(g)); const C = (function (e) {
      function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t.prototype.provideDocumentSymbols = function (e, t) {
        return c(this, void 0, void 0, function () {
          let t; let n; let r; let o; let s; const a = this; return d(this, function (u) {
            switch (u.label) {
              case 0:return t = e.uri, [4, this._worker(t)]; case 1:return n = u.sent(), e.isDisposed() ? [2] : [4, n.getNavigationBarItems(t.toString())]; case 2:return r = u.sent(), !r || e.isDisposed()
                ? [2]
                : (o = function (t, n, r) {
                    const s = { name: n.text, detail: '', kind: j[n.kind] || i.Mj.SymbolKind.Variable, range: a._textSpanToRange(e, n.spans[0]), selectionRange: a._textSpanToRange(e, n.spans[0]), tags: [], containerName: r }; if (n.childItems && n.childItems.length > 0)
                      for (let u = 0, l = n.childItems; u < l.length; u++) { const c = l[u]; o(t, c, s.name) }t.push(s)
                  }, s = [], r.forEach((e) => { return o(s, e) }), [2, s])
            }
          })
        })
      }, t
    }(g)); var M = (function () { function e() {} return e.unknown = '', e.keyword = 'keyword', e.script = 'script', e.module = 'module', e.class = 'class', e.interface = 'interface', e.type = 'type', e.enum = 'enum', e.variable = 'var', e.localVariable = 'local var', e.function = 'function', e.localFunction = 'local function', e.memberFunction = 'method', e.memberGetAccessor = 'getter', e.memberSetAccessor = 'setter', e.memberVariable = 'property', e.constructorImplementation = 'constructor', e.callSignature = 'call', e.indexSignature = 'index', e.constructSignature = 'construct', e.parameter = 'parameter', e.typeParameter = 'type parameter', e.primitiveType = 'primitive type', e.label = 'label', e.alias = 'alias', e.const = 'const', e.let = 'let', e.warning = 'warning', e }()); var j = Object.create(null); j[M.module] = i.Mj.SymbolKind.Module, j[M.class] = i.Mj.SymbolKind.Class, j[M.enum] = i.Mj.SymbolKind.Enum, j[M.interface] = i.Mj.SymbolKind.Interface, j[M.memberFunction] = i.Mj.SymbolKind.Method, j[M.memberVariable] = i.Mj.SymbolKind.Property, j[M.memberGetAccessor] = i.Mj.SymbolKind.Property, j[M.memberSetAccessor] = i.Mj.SymbolKind.Property, j[M.variable] = i.Mj.SymbolKind.Variable, j[M.const] = i.Mj.SymbolKind.Variable, j[M.localVariable] = i.Mj.SymbolKind.Variable, j[M.variable] = i.Mj.SymbolKind.Variable, j[M.function] = i.Mj.SymbolKind.Function, j[M.localFunction] = i.Mj.SymbolKind.Function; let D; let F; const I = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t._convertOptions = function (e) { return { ConvertTabsToSpaces: e.insertSpaces, TabSize: e.tabSize, IndentSize: e.tabSize, IndentStyle: r.Smart, NewLineCharacter: '\n', InsertSpaceAfterCommaDelimiter: !0, InsertSpaceAfterSemicolonInForStatements: !0, InsertSpaceBeforeAndAfterBinaryOperators: !0, InsertSpaceAfterKeywordsInControlFlowStatements: !0, InsertSpaceAfterFunctionKeywordForAnonymousFunctions: !0, InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: !1, InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: !1, InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: !1, PlaceOpenBraceOnNewLineForControlBlocks: !1, PlaceOpenBraceOnNewLineForFunctions: !1 } }, t.prototype._convertTextChanges = function (e, t) { return { text: t.newText, range: this._textSpanToRange(e, t.span) } }, t }(g)); const T = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t.prototype.provideDocumentRangeFormattingEdits = function (e, t, n, r) { return c(this, void 0, void 0, function () { let r; let i; let o; let s; let a; const u = this; return d(this, function (l) { switch (l.label) { case 0:return r = e.uri, i = e.getOffsetAt({ lineNumber: t.startLineNumber, column: t.startColumn }), o = e.getOffsetAt({ lineNumber: t.endLineNumber, column: t.endColumn }), [4, this._worker(r)]; case 1:return s = l.sent(), e.isDisposed() ? [2] : [4, s.getFormattingEditsForRange(r.toString(), i, o, I._convertOptions(n))]; case 2:return a = l.sent(), !a || e.isDisposed() ? [2] : [2, a.map((t) => { return u._convertTextChanges(e, t) })] } }) }) }, t }(I)); const P = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), Object.defineProperty(t.prototype, 'autoFormatTriggerCharacters', { get() { return [';', '}', '\n'] }, enumerable: !1, configurable: !0 }), t.prototype.provideOnTypeFormattingEdits = function (e, t, n, r, i) { return c(this, void 0, void 0, function () { let i; let o; let s; let a; const u = this; return d(this, function (l) { switch (l.label) { case 0:return i = e.uri, o = e.getOffsetAt(t), [4, this._worker(i)]; case 1:return s = l.sent(), e.isDisposed() ? [2] : [4, s.getFormattingEditsAfterKeystroke(i.toString(), o, n, I._convertOptions(r))]; case 2:return a = l.sent(), !a || e.isDisposed() ? [2] : [2, a.map((t) => { return u._convertTextChanges(e, t) })] } }) }) }, t }(I)); const L = (function (e) { function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t.prototype.provideCodeActions = function (e, t, n, r) { return c(this, void 0, void 0, function () { let r; let i; let o; let s; let a; let u; let l; let c; const p = this; return d(this, function (d) { switch (d.label) { case 0:return r = e.uri, i = e.getOffsetAt({ lineNumber: t.startLineNumber, column: t.startColumn }), o = e.getOffsetAt({ lineNumber: t.endLineNumber, column: t.endColumn }), s = I._convertOptions(e.getOptions()), a = n.markers.filter((e) => { return e.code }).map((e) => { return e.code }).map(Number), [4, this._worker(r)]; case 1:return u = d.sent(), e.isDisposed() ? [2] : [4, u.getCodeFixesAtPosition(r.toString(), i, o, a, s)]; case 2:return l = d.sent(), !l || e.isDisposed() ? [2, { actions: [], dispose() {} }] : (c = l.filter((e) => { return e.changes.filter((e) => { return e.isNewFile }).length === 0 }).map((t) => { return p._tsCodeFixActionToMonacoCodeAction(e, n, t) }), [2, { actions: c, dispose() {} }]) } }) }) }, t.prototype._tsCodeFixActionToMonacoCodeAction = function (e, t, n) { for (var r = [], i = 0, o = n.changes; i < o.length; i++) for (let s = o[i], a = 0, u = s.textChanges; a < u.length; a++) { const l = u[a]; r.push({ resource: e.uri, edit: { range: this._textSpanToRange(e, l.span), text: l.newText } }) } const c = { title: n.description, edit: { edits: r }, diagnostics: t.markers, kind: 'quickfix' }; return c }, t }(I)); const A = (function (e) {
      function t() { return e !== null && e.apply(this, arguments) || this } return l(t, e), t.prototype.provideRenameEdits = function (e, t, n, r) {
        return c(this, void 0, void 0, function () {
          let r, o, s, a, u, l, c, p, f, h, g, m; return d(this, function (d) {
            switch (d.label) {
              case 0:return r = e.uri, o = r.toString(), s = e.getOffsetAt(t), [4, this._worker(r)]; case 1:return a = d.sent(), e.isDisposed() ? [2] : [4, a.getRenameInfo(o, s, { allowRenameOfImportPath: !1 })]; case 2:if (u = d.sent(), !1 === u.canRename)
                return [2, { edits: [], rejectReason: u.localizedErrorMessage }]; if (void 0 !== u.fileToRename)
                  throw new Error('Renaming files is not supported.'); return [4, a.findRenameLocations(o, s, !1, !1, !1)]; case 3:if (l = d.sent(), !l || e.isDisposed())
                return [2]; for (c = [], p = 0, f = l; p < f.length; p++) {
                  if (h = f[p], g = i.Sf.parse(h.fileName), m = i.j6.getModel(g), !m)
                    throw new Error(`Unknown URI ${g}.`); c.push({ resource: g, edit: { range: this._textSpanToRange(m, h.textSpan), text: n } })
                } return [2, { edits: c }]
            }
          })
        })
      }, t
    }(g)); function O(e) { F = R(e, 'typescript') } function N(e) { D = R(e, 'javascript') } function E() {
      return new Promise((e, t) => {
        if (!D)
          return t('JavaScript not registered!'); e(D)
      })
    } function K() {
      return new Promise((e, t) => {
        if (!F)
          return t('TypeScript not registered!'); e(F)
      })
    } function R(e, t) { const n = new a(t, e); const r = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return n.getLanguageServiceWorker.apply(n, e) }; const o = new m(r); return i.Mj.registerCompletionItemProvider(t, new v(r)), i.Mj.registerSignatureHelpProvider(t, new _(r)), i.Mj.registerHoverProvider(t, new S(r)), i.Mj.registerDocumentHighlightProvider(t, new w(r)), i.Mj.registerDefinitionProvider(t, new k(o, r)), i.Mj.registerReferenceProvider(t, new x(o, r)), i.Mj.registerDocumentSymbolProvider(t, new C(r)), i.Mj.registerDocumentRangeFormattingEditProvider(t, new T(r)), i.Mj.registerOnTypeFormattingEditProvider(t, new P(r)), i.Mj.registerCodeActionProvider(t, new L(r)), i.Mj.registerRenameProvider(t, new A(r)), new b(o, e, t, r), r }
  },
}])
