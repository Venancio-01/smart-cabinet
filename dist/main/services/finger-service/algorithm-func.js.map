{"version":3,"sources":["../../../../src/main/services/finger-service/algorithm-func.ts"],"sourcesContent":["import { existsSync } from 'fs'\nimport { execSync } from 'child_process'\nimport { Library } from 'ffi-napi'\nimport { HandleType, IntType, TemplateType, UcharType } from './types'\nimport { ALGORITHM_SDK_PATH, LIBZKFINGER10_PATH, VERIFY_SCORE_THRESHOLD } from '@/config'\n\nlet algorithmSDK = null\nconst zkfingerLibPath = '/usr/lib/libzkfinger10.so'\n\n// 检查 libzkfinger10.so 文件是否存在，如果不存在则复制文件\nexport function checkFileExist() {\n  if (!existsSync(zkfingerLibPath)) {\n    // 文件不存在，复制文件\n    try {\n      execSync(`sudo cp ${LIBZKFINGER10_PATH} ${zkfingerLibPath}`)\n      console.log('libzkfinger10.so 文件复制成功')\n    }\n    catch (err) {\n      console.error(err)\n    }\n  }\n  else {\n    console.log('libzkfinger10.so 文件已存在')\n  }\n}\n\n// 通过 ffi 解析 C++ SDK 方法\nexport function initAlgorithmSDK() {\n  algorithmSDK = Library(ALGORITHM_SDK_PATH, {\n    BIOKEY_INIT_SIMPLE: [HandleType, ['int', 'int', 'int', 'int']], // 初始化算法\n    BIOKEY_CLOSE: ['int', [HandleType]], // 释放算法\n    BIOKEY_EXTRACT_GRAYSCALEDATA: ['int', [HandleType, UcharType, 'int', 'int', UcharType, 'int', 'int']], // 提取模版\n    BIOKEY_IDENTIFYTEMP: ['int', [HandleType, UcharType, IntType, IntType]], // 1:N 识别\n    BIOKEY_GENTEMPLATE: ['int', [HandleType, TemplateType, 'int', UcharType]], // ⽣成登记特征(多个模板之中取最好)\n    BIOKEY_VERIFY: ['int', [HandleType, UcharType, UcharType]], // 对比两个模板\n    BIOKEY_DB_ADD: ['int', [HandleType, 'int', 'int', UcharType]], // 添加模板到1:N内存中\n  })\n}\n\nexport function destroyAlgorithmSDK() {\n  algorithmSDK = null\n}\n\n/**\n * @description: 初始化算法\n * @param {number} width 设备宽度\n * @param {number} height 设备高度\n * @return {*} 返回算法句柄\n */\nexport function initAlgorithm(width: number, height: number) {\n  return algorithmSDK.BIOKEY_INIT_SIMPLE(0, width, height, 0)\n}\n\n/**\n * @description: 释放算法\n * @param {unknown} handle 算法句柄\n * @return {*} 1 表⽰成功,其余表⽰失败\n */\nexport function closeAlgorithm(handle: unknown): number {\n  return algorithmSDK.BIOKEY_CLOSE(handle)\n}\n\n/**\n * @description: 生成注册的指纹模板\n * @param {unknown} handle 算法句柄\n * @param {unknown} templates 模板数组\n * @param {number} num 数组个数\n * @param {unknown} gTemplate 返回最好的模板(建议分配2048字节)\n * @return {*} >0 表⽰成功，值为最好模板的实际数据⻓度\n */\nexport function generateTemplate(handle, templates, num, gTemplate) {\n  const result = algorithmSDK.BIOKEY_GENTEMPLATE(handle, templates, num, gTemplate)\n  const success = result > 0\n  return {\n    success,\n    result,\n  }\n}\n\n/**\n * @description: 对比两个模板\n * @param {*} handle 算法句柄\n * @param {*} template1 模板一\n * @param {*} template2 模板二\n * @return {boolean} 返回比对成功的结果\n */\nexport function verifyTemplate(handle, template1, template2): boolean {\n  // 返回分数(0~1000), 推荐阈值50\n  const result = algorithmSDK.BIOKEY_VERIFY(handle, template1, template2)\n\n  const success = result >= VERIFY_SCORE_THRESHOLD\n  return success\n}\n\n/**\n * @description: 指纹 1:N 比对\n * @param {unknown} handle 算法句柄\n * @param {unknown} templateDate 模版数据\n * @param {unknown} tid 返回识别成功的指纹ID\n * @param {unknown} score 返回识别成功的分数(推荐阈值70)\n * @return {number} 成功返回1\n */\nexport function identifyTemplate(handle: unknown, templateDate: unknown, tid: unknown, score: unknown): number {\n  return algorithmSDK.BIOKEY_IDENTIFYTEMP(handle, templateDate, tid, score)\n}\n\n/**\n * @description: 提取模版\n * @param {unknown} handle 算法句柄\n * @param {unknown} imageBuffer sensorCapture 提取的图像数据\n * @param {number} width 图像宽度\n * @param {number} height 图像高度\n * @param {unknown} template 返回指纹模版数据（建议 2048 字节）\n * @param {number} len\n * @return {number} > 0 表⽰提取成功，返回模板数据实际⻓度\n */\nexport function extractTemplate(handle: unknown,\n  imageBuffer: unknown,\n  width: number,\n  height: number,\n  template: unknown,\n  len: number): number {\n  return algorithmSDK.BIOKEY_EXTRACT_GRAYSCALEDATA(handle, imageBuffer, width, height, template, len, 0)\n}\n\n/**\n * @description: 添加模板到1:N内存中\n * @param {unknown} handle 算法句柄\n * @param {number} tid 指纹id\n * @param {number} templateLength 指纹模板数据长度\n * @param {unknown} templateData 指纹模板数据\n * @return {*} 返回添加结果和代码\n */\nexport function addTemplateToDb(handle: unknown, tid: number, templateLength: number, templateData: unknown) {\n  const result = algorithmSDK.BIOKEY_DB_ADD(handle, tid, templateLength, templateData)\n  const success = result === 1\n  return { success, result }\n}\n"],"names":["checkFileExist","initAlgorithmSDK","destroyAlgorithmSDK","initAlgorithm","closeAlgorithm","generateTemplate","verifyTemplate","identifyTemplate","extractTemplate","addTemplateToDb","algorithmSDK","zkfingerLibPath","existsSync","execSync","LIBZKFINGER10_PATH","console","log","err","error","Library","ALGORITHM_SDK_PATH","BIOKEY_INIT_SIMPLE","HandleType","BIOKEY_CLOSE","BIOKEY_EXTRACT_GRAYSCALEDATA","UcharType","BIOKEY_IDENTIFYTEMP","IntType","BIOKEY_GENTEMPLATE","TemplateType","BIOKEY_VERIFY","BIOKEY_DB_ADD","width","height","handle","templates","num","gTemplate","result","success","template1","template2","VERIFY_SCORE_THRESHOLD","templateDate","tid","score","imageBuffer","template","len","templateLength","templateData"],"mappings":";;;;;;;;;;;IAUgBA,cAAc;eAAdA;;IAiBAC,gBAAgB;eAAhBA;;IAYAC,mBAAmB;eAAnBA;;IAUAC,aAAa;eAAbA;;IASAC,cAAc;eAAdA;;IAYAC,gBAAgB;eAAhBA;;IAgBAC,cAAc;eAAdA;;IAgBAC,gBAAgB;eAAhBA;;IAcAC,eAAe;eAAfA;;IAiBAC,eAAe;eAAfA;;;kBArIW;6BACF;uBACD;qBACqC;sBACkB;AAE/E,IAAIC,eAAe;AACnB,IAAMC,kBAAkB;AAGjB,SAASX;IACd,IAAI,CAACY,IAAAA,gBAAWD,kBAAkB;QAChC,aAAa;QACb,IAAI;YACFE,IAAAA,yBAAS,AAAC,WAAgCF,OAAtBG,4BAAmB,KAAmB,OAAhBH;YAC1CI,QAAQC,IAAI;QACd,EACA,OAAOC,KAAK;YACVF,QAAQG,MAAMD;QAChB;IACF,OACK;QACHF,QAAQC,IAAI;IACd;AACF;AAGO,SAASf;IACdS,eAAeS,IAAAA,kBAAQC,4BAAoB;QACzCC,oBAAoB;YAACC;YAAY;gBAAC;gBAAO;gBAAO;gBAAO;aAAM;SAAC;QAC9DC,cAAc;YAAC;YAAO;gBAACD;aAAW;SAAC;QACnCE,8BAA8B;YAAC;YAAO;gBAACF;gBAAYG;gBAAW;gBAAO;gBAAOA;gBAAW;gBAAO;aAAM;SAAC;QACrGC,qBAAqB;YAAC;YAAO;gBAACJ;gBAAYG;gBAAWE;gBAASA;aAAQ;SAAC;QACvEC,oBAAoB;YAAC;YAAO;gBAACN;gBAAYO;gBAAc;gBAAOJ;aAAU;SAAC;QACzEK,eAAe;YAAC;YAAO;gBAACR;gBAAYG;gBAAWA;aAAU;SAAC;QAC1DM,eAAe;YAAC;YAAO;gBAACT;gBAAY;gBAAO;gBAAOG;aAAU;SAAC;IAC/D;AACF;AAEO,SAASvB;IACdQ,eAAe;AACjB;AAQO,SAASP,cAAc6B,KAAa,EAAEC,MAAc;IACzD,OAAOvB,aAAaW,mBAAmB,GAAGW,OAAOC,QAAQ;AAC3D;AAOO,SAAS7B,eAAe8B,MAAe;IAC5C,OAAOxB,aAAaa,aAAaW;AACnC;AAUO,SAAS7B,iBAAiB6B,MAAM,EAAEC,SAAS,EAAEC,GAAG,EAAEC,SAAS;IAChE,IAAMC,SAAS5B,aAAakB,mBAAmBM,QAAQC,WAAWC,KAAKC;IACvE,IAAME,UAAUD,SAAS;IACzB,OAAO;QACLC,SAAAA;QACAD,QAAAA;IACF;AACF;AASO,SAAShC,eAAe4B,MAAM,EAAEM,SAAS,EAAEC,SAAS;IACzD,uBAAuB;IACvB,IAAMH,SAAS5B,aAAaoB,cAAcI,QAAQM,WAAWC;IAE7D,IAAMF,UAAUD,UAAUI;IAC1B,OAAOH;AACT;AAUO,SAAShC,iBAAiB2B,MAAe,EAAES,YAAqB,EAAEC,GAAY,EAAEC,KAAc;IACnG,OAAOnC,aAAagB,oBAAoBQ,QAAQS,cAAcC,KAAKC;AACrE;AAYO,SAASrC,gBAAgB0B,MAAe,EAC7CY,WAAoB,EACpBd,KAAa,EACbC,MAAc,EACdc,QAAiB,EACjBC,GAAW;IACX,OAAOtC,aAAac,6BAA6BU,QAAQY,aAAad,OAAOC,QAAQc,UAAUC,KAAK;AACtG;AAUO,SAASvC,gBAAgByB,MAAe,EAAEU,GAAW,EAAEK,cAAsB,EAAEC,YAAqB;IACzG,IAAMZ,SAAS5B,aAAaqB,cAAcG,QAAQU,KAAKK,gBAAgBC;IACvE,IAAMX,UAAUD,WAAW;IAC3B,OAAO;QAAEC,SAAAA;QAASD,QAAAA;IAAO;AAC3B"}